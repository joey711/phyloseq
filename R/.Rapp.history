?error
?stop
get.component.classes()
access <- function(object, slot, errorIfNULL=FALSE){#
	component.classes <- get.component.classes()#
	# Check if class of x is among the component classes (not H.O.)#
	if( class(object) %in% component.classes ){#
		# if slot-name matches object, return object as-is.#
		if( component.classes[slot] == class(object) ){#
			out <- object#
		} else {#
			out <- NULL#
		}#
	} else if(!slot %in% slotNames(object) ){#
		out <- NULL#
	} else {#
		out <- eval(parse(text=paste("object@", slot, sep=""))) #
	}#
	# Test if you should error upon the emptiness of the slot being accessed#
	if( errorIfNULL & is.null(out) ){#
		stop(slot, "slot is empty.")#
	}#
	return(out)#
}
access(otuTable(ex1), "sampleMap")
access(otuTable(ex1), "sampleMap", TRUE)
access <- function(object, slot, errorIfNULL=FALSE){#
	component.classes <- get.component.classes()#
	# Check if class of x is among the component classes (not H.O.)#
	if( class(object) %in% component.classes ){#
		# if slot-name matches object, return object as-is.#
		if( component.classes[slot] == class(object) ){#
			out <- object#
		} else {#
			out <- NULL#
		}#
	} else if(!slot %in% slotNames(object) ){#
		out <- NULL#
	} else {#
		out <- eval(parse(text=paste("object@", slot, sep=""))) #
	}#
	# Test if you should error upon the emptiness of the slot being accessed#
	if( errorIfNULL & is.null(out) ){#
		stop(slot, " slot is empty.")#
	}#
	return(out)#
}
access(otuTable(ex1), "sampleMap", TRUE)
setMethod("sampleMap", "ANY", function(object, errorIfNULL=TRUE){#
	access(object, "sampleMap", errorIfNULL)#
})
# while for many other cases, the direct-name accessor needs to find a non-NULL or throw#
# an error because the rest of the function/method won't work without that data#
# This can be accomplished with some simple modifications to the accessors.#
setGeneric("sampleMap1", function(object, errorIfNULL=TRUE) standardGeneric("sampleMap1"))#
setMethod("sampleMap1", "ANY", function(object, errorIfNULL=TRUE){#
	access(object, "sampleMap", errorIfNULL)#
})
sampleMap1(otuTable(ex1))
sampleMap1(ex1)
sampleMap1(otuTable(ex1))
access(ps1, "sampleMap", TRUE)
access(ps0, "sampleMap", TRUE)
sampleMap1(ps0)
sampleMap1(ps0, FALSE)
# Define the new "phyloseq" class.#
#################################################################################
setClass(Class="phyloseq", representation=representation(#
	otuTable="otuTable",#
	taxTab="taxonomyTable",#
	sampleMap="sampleMap",#
	tre="phylo4"),#
	prototype=prototype(otuTable=NULL, taxTab=NULL, sampleMap=NULL, tre=NULL)#
)
#################################################################################
setClass(Class="phyloseq", #
	representation=representation(#
		otuTable="otuTable",#
		taxTab="taxonomyTable",#
		sampleMap="sampleMap",#
		tre="phylo4"#
	),#
	prototype=prototype(otuTable=NULL, taxTab=NULL, sampleMap=NULL, tre=NULL)#
)
library("phyloseq")
# Define the new "phyloseq" class.#
#################################################################################
setClass(Class="phyloseq", #
	representation=representation(#
		otuTable="otuTable",#
		taxTab="taxonomyTable",#
		sampleMap="sampleMap",#
		tre="phylo4"#
	),#
	prototype=prototype(otuTable=NULL, taxTab=NULL, sampleMap=NULL, tre=NULL)#
)
new("phyloseq")
new("phyloseq", otuTable=otuTable(ex1), taxTab=taxTab(ex1))
data(ex1)
new("phyloseq", otuTable=otuTable(ex1), taxTab=taxTab(ex1))
library("phylobase")
?phylo4
?"phylo4-class"
library("phyloseq")
?otuTable
?tre
data(ex1)
rownames(sampleMap(ex1))
rownames(matrix(3,5,5))
matrix(3,5,5)
#' #    matrix(sample(c("a","b","c"),150,TRUE), 25, 6) )#
#' # map1 <- sampleMap(map1) #
#' # ex1 <- phyloseq(OTU1, map1, tax1)#
#' # otuTable(ex1)#
setGeneric("otuTable", function(object, speciesAreRows) standardGeneric("otuTable"))#
# Access the otuTable slot, or return an otuTable as-is.#
#' @aliases otuTable,phyloseqFather-method#
#' @rdname otuTable-methods#
setMethod("otuTable", "phyloseqFather", function(object) access(object, "otuTable") )#
#' @aliases otuTable,otuTable-method#
#' @rdname otuTable-methods#
setMethod("otuTable", "otuTable", function(object) access(object, "otuTable") )#
# # # Instantiate an otuTable from a raw abundance matrix.#
# # # #
# # # @param object An abundance table in the form of an integer matrix. #
# # #  \code{speciesAreRows} must be specified in \code{...}-argument .#
# # # @param ... The additional named argument \code{speciesAreRows} must be #
# # #  provided. A logical.#
#' @aliases otuTable,matrix-method#
#' @rdname otuTable-methods#
setMethod("otuTable", "matrix", function(object, speciesAreRows){#
	# Want dummy species/sample index names if missing#
	if(speciesAreRows){#
		if(is.null(rownames(object))){#
			rownames(object) <- paste("sp", 1:nrow(object), sep="")#
		}#
		if(is.null(colnames(object))){#
			colnames(object) <- paste("sa", 1:ncol(object), sep="")#
		}#
	} else {#
		if(is.null(rownames(object))){#
			rownames(object) <- paste("sa",1:nrow(object),sep="")#
		}#
		if(is.null(colnames(object))){#
			colnames(object) <- paste("sp",1:ncol(object),sep="")#
		}#
	}#
	new("otuTable", object, speciesAreRows=speciesAreRows)#
})#
# # # Convert to matrix, then instantiate otuTable.#
#' @aliases otuTable,data.frame-method#
#' @rdname otuTable-methods#
setMethod("otuTable", "data.frame", function(object, speciesAreRows){#
	otuTable(as(object, "matrix"), speciesAreRows)#
})
otuTable(matrix(5,5,5), TRUE)
		HO
setClassUnion("taxTabOrNULL", c("taxonomyTable", "NULL"))
library("phylobase")
#################################################################################
#' The S4 class for storing taxa-abundance information.#
#'#
#' Because orientation of these tables can vary by method, the orientation is#
#' defined explicitly in the \code{speciesAreRows} slot (a logical).#
#' The \code{otuTable} class inherits the \code{\link{matrix}} class to store#
#' abundance values.#
#' Various standard subset and assignment nomenclature has been extended to apply#
#' to the \code{otuTable} class, including square-bracket, \code{\link{t}}, etc.#
#'#
#' \describe{#
#'    \item{speciesAreRows}{#
#'		A single logical specifying the orientation of the abundance table.#
#'    }#
#'#
#'    \item{.Data}{This slot is inherited from the \code{\link{matrix}} class.}#
#'  }#
#' @name otuTable-class#
#' @rdname otuTable-class#
#' @exportClass otuTable#
setClass("otuTable", representation(speciesAreRows="logical", contains = "matrix") )#
#################################################################################
#' The S4 for storing sample variables.#
#'#
#' Row indices represent samples, while column indices represent experimental#
#' categories, variables (and so forth) that describe the samples.#
#'#
#' \describe{#
#'#
#'    \item{.Data}{data-frame data, inherited from the data.frame class.}#
#' #
#'    \item{row.names}{#
#'	     Also inherited from the data.frame class;#
#'       it should contain the sample names.#
#'    }#
#' #
#'    \item{names}{Inherited from the data.frame class.}#
#' #
#'  }#
#' #
#' @name sampleMap-class#
#' @rdname sampleMap-class#
#' @exportClass sampleMap#
setClass("sampleMap", contains="data.frame")#
#################################################################################
#' An S4 class that holds taxonomic classification data as a character#
#' matrix.#
#'#
#' Row indices represent taxa, columns represent taxonomic classifiers.#
#' #
#' \describe{#
#'    \item{.Data}{This slot is inherited from the \code{\link{matrix}} class.}#
#' }#
#'#
#' @name taxonomyTable-class#
#' @rdname taxonomyTable-class#
#' @exportClass taxonomyTable#
setClass("taxonomyTable", contains = "matrix")#
#################################################################################
# Use setClassUnion to define the unholy NULL-data union as a virtual class.#
# This is a way of dealing with the expected scenarios in which one or more of#
# the component data classes is not available, in which case NULL will be used#
# instead.#
#################################################################################
#' @keywords internal#
setClassUnion("otuTableOrNULL", c("otuTable", "NULL"))#
#' @keywords internal#
setClassUnion("sampleMapOrNULL", c("sampleMap", "NULL"))#
#' @keywords internal#
setClassUnion("taxTabOrNULL", c("taxonomyTable", "NULL"))#
#' @keywords internal#
setClassUnion("treeOrNULL", c("phylo4", "NULL")) # suppress warnings?#
#################################################################################
# The actual phyloseq master class with all 4 slots. This is akin to #
# the otuSamTaxTree class of previous versions, but #
# with the possibility of empty (NULL) slots and an explicit prototype #
# for slots to be NULL if they are not provided at instantiation.#
#################################################################################
#' The main experiment-level class for phyloseq data#
#'#
#' Contains all component classes: #
#' \code{\link{otuTable-class}},#
#' \code{\link{sampleMap-class}},#
#' \code{\link{taxonomyTable-class}} (\code{"taxTab"} slot), and#
#' \code{\link{phylo4-class}} (\code{"tre"} slot). There are several advantages#
#' to storing your phylogenetic sequencing experiment as an instance of the#
#' phyloseq class, not the least of which is that it is easy to return to the#
#' data later and feel confident that the different data types ``belong'' to#
#' one another. Furthermore, the \code{\link{phyloseq}} constructor ensures that#
#' the different data components have compatible indices (e.g. species and samples),#
#' and performs the necessary trimming automatically when you create your#
#' ``experiment-level'' object. Downstream analyses are aware of which data#
#' classes they require -- and where to find them -- often making your #
#' \code{phyloseq-class} object the only data argument to analysis and plotting#
#' functions (although there are many options and parameter arguments waiting#
#' for you). #
#'#
#' In the case of missing component data, the slots are set to \code{NULL}. As#
#' soon as a \code{phyloseq-class} object is to be updated with new component#
#' data (previously missing/\code{NULL} or not), the indices of all components#
#' are re-checked for compatibility and trimmed if necessary. This is to ensure#
#' by design that components describe the same taxa/samples, and also that these#
#' trimming/validity checks do not need to be repeated in downstream analyses.#
#' #
#' slots:#
#' \describe{#
#'    \item{otuTable}{a single object of class otuTable.}#
#'    \item{sampleMap}{ a single object of class sampleMap.}#
#'    \item{taxTab}{ a single object of class taxonomyTable.}#
#'    \item{tre}{ a single object of class phylo, from the package ape}#
#' }#
#' @seealso The constructor, \code{\link{phyloseq}}, #
#'  the merger \code{\link{merge_phyloseq}}, and also the component #
#'  constructor/accessors \code{\link{otuTable}}, \code{\link{sampleMap}},#
#'  \code{\link{taxTab}}, and \code{\link{tre}}.#
#' #
#' @name phyloseq-class#
#' @rdname phyloseq-class#
#' @exportClass phyloseq#
setClass(Class="phyloseq", #
	representation=representation(#
		otuTable="otuTableOrNULL",#
		taxTab="taxTabOrNULL",#
		sampleMap="sampleMapOrNULL",#
		tre="treeOrNULL"),#
	prototype=prototype(otuTable=NULL, taxTab=NULL, sampleMap=NULL, tre=NULL)#
)
getSlots("phyloseq")
#################################################################################
#' The S4 class for storing taxa-abundance information.#
#'#
#' Because orientation of these tables can vary by method, the orientation is#
#' defined explicitly in the \code{speciesAreRows} slot (a logical).#
#' The \code{otuTable} class inherits the \code{\link{matrix}} class to store#
#' abundance values.#
#' Various standard subset and assignment nomenclature has been extended to apply#
#' to the \code{otuTable} class, including square-bracket, \code{\link{t}}, etc.#
#'#
#' \describe{#
#'    \item{speciesAreRows}{#
#'		A single logical specifying the orientation of the abundance table.#
#'    }#
#'#
#'    \item{.Data}{This slot is inherited from the \code{\link{matrix}} class.}#
#'  }#
#' @name otuTable-class#
#' @rdname otuTable-class#
#' @exportClass otuTable#
setClass("otuTable", representation(speciesAreRows="logical", contains = "matrix") )#
#################################################################################
#' The S4 for storing sample variables.#
#'#
#' Row indices represent samples, while column indices represent experimental#
#' categories, variables (and so forth) that describe the samples.#
#'#
#' \describe{#
#'#
#'    \item{.Data}{data-frame data, inherited from the data.frame class.}#
#' #
#'    \item{row.names}{#
#'	     Also inherited from the data.frame class;#
#'       it should contain the sample names.#
#'    }#
#' #
#'    \item{names}{Inherited from the data.frame class.}#
#' #
#'  }#
#' #
#' @name sampleMap-class#
#' @rdname sampleMap-class#
#' @exportClass sampleMap#
setClass("sampleMap", contains="data.frame")#
#################################################################################
#' An S4 class that holds taxonomic classification data as a character#
#' matrix.#
#'#
#' Row indices represent taxa, columns represent taxonomic classifiers.#
#' #
#' \describe{#
#'    \item{.Data}{This slot is inherited from the \code{\link{matrix}} class.}#
#' }#
#'#
#' @name taxonomyTable-class#
#' @rdname taxonomyTable-class#
#' @exportClass taxonomyTable#
setClass("taxonomyTable", contains = "matrix")#
#################################################################################
# Use setClassUnion to define the unholy NULL-data union as a virtual class.#
# This is a way of dealing with the expected scenarios in which one or more of#
# the component data classes is not available, in which case NULL will be used#
# instead.#
#################################################################################
#' @keywords internal#
setClassUnion("otuTableOrNULL", c("otuTable", "NULL"))#
#' @keywords internal#
setClassUnion("sampleMapOrNULL", c("sampleMap", "NULL"))#
#' @keywords internal#
setClassUnion("taxonomyTableOrNULL", c("taxonomyTable", "NULL"))#
#' @keywords internal#
setClassUnion("phylo4OrNULL", c("phylo4", "NULL")) # suppress warnings?#
#################################################################################
# The actual phyloseq master class with all 4 slots. This is akin to #
# the otuSamTaxTree class of previous versions, but #
# with the possibility of empty (NULL) slots and an explicit prototype #
# for slots to be NULL if they are not provided at instantiation.#
#################################################################################
#' The main experiment-level class for phyloseq data#
#'#
#' Contains all component classes: #
#' \code{\link{otuTable-class}},#
#' \code{\link{sampleMap-class}},#
#' \code{\link{taxonomyTable-class}} (\code{"taxTab"} slot), and#
#' \code{\link{phylo4-class}} (\code{"tre"} slot). There are several advantages#
#' to storing your phylogenetic sequencing experiment as an instance of the#
#' phyloseq class, not the least of which is that it is easy to return to the#
#' data later and feel confident that the different data types ``belong'' to#
#' one another. Furthermore, the \code{\link{phyloseq}} constructor ensures that#
#' the different data components have compatible indices (e.g. species and samples),#
#' and performs the necessary trimming automatically when you create your#
#' ``experiment-level'' object. Downstream analyses are aware of which data#
#' classes they require -- and where to find them -- often making your #
#' \code{phyloseq-class} object the only data argument to analysis and plotting#
#' functions (although there are many options and parameter arguments waiting#
#' for you). #
#'#
#' In the case of missing component data, the slots are set to \code{NULL}. As#
#' soon as a \code{phyloseq-class} object is to be updated with new component#
#' data (previously missing/\code{NULL} or not), the indices of all components#
#' are re-checked for compatibility and trimmed if necessary. This is to ensure#
#' by design that components describe the same taxa/samples, and also that these#
#' trimming/validity checks do not need to be repeated in downstream analyses.#
#' #
#' slots:#
#' \describe{#
#'    \item{otuTable}{a single object of class otuTable.}#
#'    \item{sampleMap}{ a single object of class sampleMap.}#
#'    \item{taxTab}{ a single object of class taxonomyTable.}#
#'    \item{tre}{ a single object of class phylo, from the package ape}#
#' }#
#' @seealso The constructor, \code{\link{phyloseq}}, #
#'  the merger \code{\link{merge_phyloseq}}, and also the component #
#'  constructor/accessors \code{\link{otuTable}}, \code{\link{sampleMap}},#
#'  \code{\link{taxTab}}, and \code{\link{tre}}.#
#' #
#' @name phyloseq-class#
#' @rdname phyloseq-class#
#' @exportClass phyloseq#
setClass(Class="phyloseq", #
	representation=representation(#
		otuTable="otuTableOrNULL",#
		taxTab="taxonomyTableOrNULL",#
		sampleMap="sampleMapOrNULL",#
		tre="phylo4OrNULL"),#
	prototype=prototype(otuTable=NULL, taxTab=NULL, sampleMap=NULL, tre=NULL)#
)
getSlots("phyloseq")
#################################################################################
### Accessor / subset methods.#
#################################################################################
#' Build or access otuTable objects.#
#'#
#' \code{otuTable()} is both a constructor and accessor method. When the first#
#' argument is a matrix, otuTable() will attempt to create and return an #
#' otuTable-class object,#
#' which further depends on whether or not speciesAreRows is provided as an#
#' additional argument. Alternatively, if the first argument is an object that #
#' contains an otuTable, including an otuTable-class object, then the #
#' corresponding otuTable is returned, as the component object by itself.#
#' This is a convenience wrapper on the more general \code{\link{access}} function#
#' specific for grabbing the otuTable of an object.#
#' It should work on both otuTable component objects, and higher-order classes#
#' that contain an otuTable slot.#
#'#
#' This is the main method suggested for constructing otuTable objects from #
#' an abundance matrix. It is also the suggested method for accessing subsetting#
#' the otuTable from a more complex object.#
#'#
#' @usage otuTable(object, speciesAreRows, errorIfNULL=TRUE)#
#'#
#' @param object (Required). A phyloseq object.#
#'#
#' @param speciesAreRows (Conditionally optional). Ignored unless #
#'  \code{object} is a matrix, in which case \code{speciesAreRows} is required.#
#'#
#' @param errorIfNULL (Optional). Logical. Should the accessor stop with #
#'  an error if the slot is empty (\code{NULL})? Default \code{TRUE}. Ignored#
#'  if \code{object} argument is a matrix (constructor invoked instead).#
#'#
#' @return An otuTable object. It is either grabbed from the relevant slot#
#' if \code{object} is complex, or built anew if \code{object} is an integer#
#' matrix representing the species-abundance table. If \code{object} is a#
#' data.frame, then an attempt is made to coerce it to an integer matrix and#
#' instantiate an otuTable object.#
#'#
#' @name otuTable#
#' @seealso sampleMap taxTab tre phyloseq#
#' @aliases otuTable otutable otuTable,-method otuTable,otuTable-method#
#' @docType methods#
#' @rdname otuTable-methods#
#' @export#
#' @examples ##
#' # OTU1 <- otuTable(matrix(sample(0:5,250,TRUE),25,10), speciesAreRows=TRUE)#
#' # tax1 <- taxTab(matrix("abc", 30, 8))#
#' # map1 <- data.frame( matrix(sample(0:3,250,TRUE),25,10), #
#' #    matrix(sample(c("a","b","c"),150,TRUE), 25, 6) )#
#' # map1 <- sampleMap(map1) #
#' # ex1 <- phyloseq(OTU1, map1, tax1)#
#' # otuTable(ex1)#
setGeneric("otuTable", function(object, speciesAreRows, errorIfNULL=TRUE){#
	standardGeneric("otuTable")	#
})#
# Access the otuTable slot, or return an otuTable as-is.#
#' @aliases otuTable,phyloseqFather-method#
#' @rdname otuTable-methods#
setMethod("otuTable", "ANY", function(object, errorIfNULL=TRUE){#
	access(object, "otuTable", errorIfNULL) #
})#
# # # Instantiate an otuTable from a raw abundance matrix.#
# # # #
# # # @param object An abundance table in the form of an integer matrix. #
# # #  \code{speciesAreRows} must be specified in \code{...}-argument .#
# # # @param ... The additional named argument \code{speciesAreRows} must be #
# # #  provided. A logical.#
#' @aliases otuTable,matrix-method#
#' @rdname otuTable-methods#
setMethod("otuTable", "matrix", function(object, speciesAreRows){#
	# Want dummy species/sample index names if missing#
	if(speciesAreRows){#
		if(is.null(rownames(object))){#
			rownames(object) <- paste("sp", 1:nrow(object), sep="")#
		}#
		if(is.null(colnames(object))){#
			colnames(object) <- paste("sa", 1:ncol(object), sep="")#
		}#
	} else {#
		if(is.null(rownames(object))){#
			rownames(object) <- paste("sa",1:nrow(object),sep="")#
		}#
		if(is.null(colnames(object))){#
			colnames(object) <- paste("sp",1:ncol(object),sep="")#
		}#
	}#
	new("otuTable", object, speciesAreRows=speciesAreRows)#
})#
# # # Convert to matrix, then instantiate otuTable.#
#' @aliases otuTable,data.frame-method#
#' @rdname otuTable-methods#
setMethod("otuTable", "data.frame", function(object, speciesAreRows){#
	otuTable(as(object, "matrix"), speciesAreRows)#
})#
#################################################################################
#' Build or access sampleMap objects.#
#'#
#' \code{sampleMap()} is both a constructor and accessor method. When the#
#' argument is a data.frame, sampleMap() will attempt to create and return an #
#' sampleMap-class object. In this case, the rows should be named to match the#
#' \code{sample.names} of the other objects to which it will ultimately be paired.#
#' Alternatively, if the argument is an object that #
#' contains a sampleMap, including a sampleMap-class object, then the #
#' corresponding sampleMap is returned, as-is.#
#'#
#' This is the main method suggested for constructing sampleMap objects from #
#' a data.frame of sample covariates. Each row represents a different sample.#
#' It is also the suggested method for accessing/subsetting#
#' the sampleMap from a more complex object.#
#'#
#' @usage sampleMap(object, errorIfNULL=TRUE)#
#'#
#' @param object An object among the set of classes defined by the phyloseq #
#' package that contain sampleMap.#
#'#
#' @param errorIfNULL (Optional). Logical. Should the accessor stop with #
#'  an error if the slot is empty (\code{NULL})? Default \code{TRUE}. #
#'#
#' @return A sampleMap object. It is either grabbed from the relevant slot#
#' if \code{object} is complex, or built anew if \code{object} is a data.frame#
#' representing the sample covariates of an experiment.#
#'#
#' @seealso otuTable taxTab tre phyloseq sampleMap-class#
#' @aliases sampleMap samplemap#
#'#
#' @rdname sampleMap-methods#
#' @docType methods#
#' @export#
#'#
#' @examples ##
#' # OTU1 <- otuTable(matrix(sample(0:5,250,TRUE),25,10), speciesAreRows=TRUE)#
#' # tax1 <- taxTab(matrix("abc", 30, 8))#
#' # map1 <- data.frame( matrix(sample(0:3,250,TRUE),25,10), #
#' #   matrix(sample(c("a","b","c"),150,TRUE), 25, 6) ) #
#' # map1 <- sampleMap(map1)#
#' # ex1 <- phyloseq(OTU1, map1, tax1)#
#' # sampleMap(ex1)#
setGeneric("sampleMap", function(object, errorIfNULL=TRUE) standardGeneric("sampleMap"))#
#' @rdname sampleMap-methods#
#' @aliases sampleMap,ANY-method#
setMethod("sampleMap", "ANY", function(object){#
	access(object, "sampleMap", errorIfNULL)#
})#
# constructor; for creating sampleMap from a data.frame#
#' @rdname sampleMap-methods#
#' @aliases sampleMap,data.frame-method#
setMethod("sampleMap", "data.frame", function(object){#
	# Make sure there are no phantom levels in categorical variables#
	object <- reconcile_categories(object)#
	# Want dummy samples index names if missing#
	if( all(rownames(object) == as.character(1:nrow(object))) ){#
		rownames(object) <- paste("sa", 1:nrow(object), sep="")#
	}	#
	new("sampleMap", object)#
})#
#################################################################################
#' Access taxTab slot, or instantiate taxonomyTable-class.#
#'#
#' \code{taxTab()} is both a constructor and accessor method. When the#
#' argument is a character matrix, taxTab() will attempt to create and return a #
#' taxonomyTable-class object. In this case, the rows should be named to match the#
#' \code{species.names} of the other objects to which it will ultimately be paired.#
#' Alternatively, if the argument is an object that #
#' contains a taxonomyTable, including a taxonomyTable-class object, then the #
#' corresponding taxonomyTable is returned, as-is.#
#'#
#' This is the main method suggested for constructing taxonomyTable objects from #
#' a character matrix of taxonomy classifications. Each row represents a #
#' different species.#
#' It is also the suggested method for accessing/subsetting#
#' the taxonomyTable from a more complex object. \code{taxTab} is the slot name#
#' that holds the taxonomyTable-class object in a multi-component phyloseq#
#' object.#
#'#
#' @usage taxTab(object, errorIfNULL=TRUE)#
#'#
#' @param object An object among the set of classes defined by the phyloseq #
#' package that contain taxonomyTable.#
#'#
#' @param errorIfNULL (Optional). Logical. Should the accessor stop with #
#'  an error if the slot is empty (\code{NULL})? Default \code{TRUE}.#
#'#
#' @return A taxonomyTable object. It is either grabbed from the relevant slot#
#' if \code{object} is complex, or built anew if \code{object} is a #
#' character matrix representing the taxonomic classification of species in the#
#' experiment.#
#'#
#' @seealso otuTable sampleMap tre phyloseq#
#' @aliases taxTab taxtab#
#'#
#' @rdname taxTab-methods#
#' @docType methods#
#' @export#
#'#
#' @examples ##
#' # tax1 <- taxTab(matrix("abc", 30, 8))#
#' # taxTab(ex1)#
#' # tax1#
setGeneric("taxTab", function(object, errorIfNULL=TRUE) standardGeneric("taxTab"))#
#' @rdname taxTab-methods#
#' @aliases taxTab,ANY-method#
setMethod("taxTab",  "ANY", function(object, errorIfNULL=TRUE){#
	access(object, "taxTab", errorIfNULL)#
})#
# Constructor; for creating taxonomyTable from a matrix.#
#' @rdname taxTab-methods#
#' @aliases taxTab,matrix-method#
setMethod("taxTab", "matrix", function(object){#
	# Want dummy species/taxa index names if missing#
	if(is.null(rownames(object))){#
		rownames(object) <- paste("sp", 1:nrow(object), sep="")#
	}#
	if(is.null(colnames(object))){#
		colnames(object) <- paste("ta", 1:ncol(object), sep="")#
	}	#
	new("taxonomyTable", object)#
})#
#' @rdname taxTab-methods#
#' @aliases taxTab taxtab#
#' @export#
taxtab <- taxTab#
#################################################################################
#' Access tre slot, or check/coerce to phylo4 class.#
#'#
#' \code{tre()} is an accessor OR coercion method. This is the main method suggested #
#' for accessing/subsetting#
#' the phylogenetic tree (phylo4 class) from a more complex object.#
#' \code{tre} is the slot name for trees. #
#' that holds the phylo4-class object in a multi-component phyloseq-package#
#' object.#
#' #
#' Note that the tip labels should be named to match the#
#' \code{species.names} of the other objects to which it is going to be paired.#
#' The initialization methods for more complex objects automatically check for#
#' exact agreement in the set of species described by the phlyogenetic tree #
#' and the other components (taxonomyTable, otuTable). #
#' They also trim accordingly. Thus, the tip.labels in a phylo object#
#' must be named to match the#
#' \code{species.names} of the other objects to which it will ultimately be paired.#
#'#
#' @usage tre(object, errorIfNULL=TRUE)#
#' #
#' @param object (Required). An instance of phyloseq-class#
#'  that contains a phylogenetic tree. If object is a phylogenetic#
#'  tree (a component data class), then it is returned as-is.#
#'#
#' @param errorIfNULL (Optional). Logical. Should the accessor stop with #
#'  an error if the slot is empty (\code{NULL})? Default \code{TRUE}.#
#'#
#' @return A phylo4 object. It is grabbed from the tre-slot. If object#
#'  is not a phylogenetic tree and does not#
#'  contain a tre-slot, then NULL is returned. This is a convenience wrapper#
#'  of the \code{\link{access}} function.#
#'#
#' @seealso otuTable sampleMap taxTab phyloseq#
#' @export#
#' @rdname tre-methods#
#' @docType methods#
setGeneric("tre", function(object, errorIfNULL=TRUE) standardGeneric("tre"))#
#' @rdname tre-methods#
#' @aliases tre,ANY-method#
setMethod("tre", "ANY", function(object, errorIfNULL=TRUE){#
	access(object, "tre", errorIfNULL)#
})#
# Constructor; for coercing "phylo4" from a "phylo".#
#' @rdname tre-methods#
#' @aliases tre,phylo-method#
setMethod("tre", "phylo", function(object){#
	as(object, "phylo4")#
})#
#################################################################################
#' Access speciesAreRows slot from otuTable objects.#
#'#
#' @usage speciesarerows(object)#
#'#
#' @param object An object among the set of classes defined by the phyloseq #
#' package that are or contain an otuTable.#
#'#
#' @return A logical indicating the orientation of the otuTable.#
#'#
#' @seealso \code{\link{otuTable}}#
#' @aliases speciesAreRows speciesarerows#
#' @export#
speciesarerows <- function(object){#
	otuTable(object)@speciesAreRows#
}#
#' @aliases speciesAreRows speciesarerows#
#' @export#
speciesAreRows <- speciesarerows#
#################################################################################
#' Get the number of taxa/species in an object.#
#' #
#' This method works on otuTable, taxonomyTable objects, or the more#
#' complex objects that represent species, as well as phylogenetic trees ``phylo''.#
#'#
#' @usage nspecies(object)#
#'#
#' @param object An object among the set of classes defined by the phyloseq #
#' package that represent species.#
#'#
#' @return An integer indicating the number of taxa / species.#
#'#
#' @seealso species.names#
#'#
#' @rdname nspecies-methods#
#' @docType methods#
#' @export#
#'#
#' @examples ##
#' # # From "picante" package#
#' # data("phylocom")#
#' # tree <- phylocom$phylo#
#' # nspecies(tree)#
setGeneric("nspecies", function(object) standardGeneric("nspecies"))#
#' @rdname nspecies-methods#
#' @aliases nspecies,ANY-method#
setMethod("nspecies", "ANY", function(object) object@nspecies)#
#' @rdname nspecies-methods#
#' @aliases nspecies,phyloseqFather-method#
setMethod("nspecies", "phyloseqFather", function(object) nspecies(otuTable(object)) )#
#' @rdname nspecies-methods#
#' @aliases nspecies,phylo-method#
setMethod("nspecies", "phylo", function(object) length(object$tip.label) )#
#' @rdname nspecies-methods#
#' @aliases nspecies,phylo4-method#
#' @import phylobase#
setMethod("nspecies", "phylo4", function(object) length(tipLabels(object)) )#
#################################################################################
#' Get the species / taxa names from an object.#
#'#
#' This method works on otuTable, taxonomyTable objects, or the more#
#' complex objects that represent species, as well as phylogenetic trees#
#' ``phylo''.#
#'#
#' @usage species.names(object)#
#'#
#' @param object An object among the set of classes defined by the phyloseq #
#' package that represent species.#
#'#
#' @return A character vector of the names of the species in \code{object}.#
#'#
#' @seealso nspecies#
#'#
#' @rdname species.names-methods#
#' @docType methods#
#' @export#
#'#
#' @examples ##
#' # # From "picante" package#
#' # data("phylocom")#
#' # tree <- phylocom$phylo#
#' # OTU1 <- otuTable(phylocom$sample, speciesAreRows=FALSE)#
#' # species.names(tree)#
#' # species.names(OTU1)#
#' # physeq1 <- phyloseq(OTU1, tree)#
#' # species.names(physeq1)#
setGeneric("species.names", function(object) standardGeneric("species.names"))	#
#' @rdname species.names-methods#
#' @aliases species.names,otuTable-method#
setMethod("species.names", "otuTable", function(object) object@species.names)#
#' @rdname species.names-methods#
#' @aliases species.names,taxonomyTable-method#
setMethod("species.names", "taxonomyTable", function(object) rownames(object) )#
#' @rdname species.names-methods#
#' @aliases species.names,phyloseqFather-method#
setMethod("species.names", "phyloseqFather", function(object){#
	otuTable(object)@species.names#
})#
#' @rdname species.names-methods#
#' @aliases species.names,sampleMap-method#
setMethod("species.names", "sampleMap", function(object) NULL )#
#' @rdname species.names-methods#
#' @aliases species.names,phylo-method#
setMethod("species.names", "phylo", function(object) object$tip.label )#
#' @rdname species.names-methods#
#' @aliases species.names,phylo4-method#
#' @import phylobase#
setMethod("species.names", "phylo4", function(object) tipLabels(object) )#
#################################################################################
#' Get the number of samples described by an object.#
#' #
#' This method works on otuTable and sampleMap objects, as well as the more#
#' complex objects that represent samples in an experiment.#
#'#
#' @usage nsamples(object)#
#'#
#' @param object An object among the set of classes defined by the phyloseq #
#' package that represent samples.#
#'#
#' @return An integer indicating the total number of samples.#
#'#
#' @seealso nspecies sample.names#
#'#
#' @rdname nsamples-methods#
#' @docType methods#
#' @export#
#'#
#' @examples ##
#' # # From "picante" package#
#' # data("phylocom")#
#' # tree <- phylocom$phylo#
#' # OTU1 <- otuTable(phylocom$sample, speciesAreRows=FALSE)#
#' # nsamples(OTU1)#
#' # physeq1 <- phyloseq(OTU1, tree)#
#' # nsamples(physeq1)#
setGeneric("nsamples", function(object) standardGeneric("nsamples"))#
#' @rdname nsamples-methods#
#' @aliases nsamples,ANY-method#
setMethod("nsamples", "ANY", function(object) object@nsamples)#
#' @rdname nsamples-methods#
#' @aliases nsamples,phyloseqFather-method#
setMethod("nsamples", "phyloseqFather", function(object){#
	otuTable(object)@nsamples#
})#
#################################################################################
#' Get the sample names of the samples described by an object.#
#' #
#' This method works on otuTable and sampleMap objects, as well as the more#
#' complex objects that represent samples in an experiment.#
#'#
#' @usage sample.names(x)#
#'#
#' @param x (Required). An object among the set of classes defined by the phyloseq #
#' package that represent samples.#
#'#
#' @return A character vector. The names of the samples in \code{x}.#
#'#
#' @seealso species.names nsamples#
#' @aliases sample.names sampleNames#
#'#
#' @rdname sample.names-methods#
#' @docType methods#
#' @export#
#'#
#' @examples ##
#' # # From "picante" package#
#' # data("phylocom")#
#' # tree <- phylocom$phylo#
#' # OTU1 <- otuTable(phylocom$sample, speciesAreRows=FALSE)#
#' # sample.names(OTU1)#
#' # ex1 <- phyloseq(OTU1, tree)#
#' # sample.names(ex1)#
setGeneric("sample.names", function(x) standardGeneric("sample.names"))	#
#' @rdname sample.names-methods#
#' @aliases sample.names,sampleMap-method#
setMethod("sample.names", "sampleMap", function(x) x@sample.names)#
#' @rdname sample.names-methods#
#' @aliases sample.names,otuTable-method#
setMethod("sample.names", "otuTable", function(x) x@sample.names)#
#' @rdname sample.names-methods#
#' @aliases sample.names,phyloseqFather-method#
setMethod("sample.names", "phyloseqFather", function(x){#
	x@otuTable@sample.names #
})#
#' @aliases sample.names#
#' @export#
sampleNames <- sample.names#
#################################################################################
#' Show the component objects classes and slot names.#
#'#
#' There are no arguments to this function. It returns a named character#
#' when called, which can then be used for tests of component data types, etc.#
#'#
#' @usage get.component.classes()#
#' #
#' @return a character vector of the component objects classes, where each #
#' element is named by the corresponding slot name in the higher-order #
#' phyloseq objects (objects containing more than 1 phyloseq data object).#
#' @export#
#' @examples ##
#' #get.component.classes()#
get.component.classes <- function(){#
	# define classes vector#
	component.classes <- c("otuTable", "sampleMap", "phylo4", "phylo", "taxonomyTable")#
	# the names of component.classes needs to be the slot names to match getSlots / splat#
	names(component.classes) <- c("otuTable", "sampleMap", "tre", "old-tre", "taxTab")	#
	return(component.classes)#
}#
#################################################################################
#' Convert phyloseq objects into a named list of the component type (class)#
#'#
#' @usage splat.phyloseq.objects(x)#
#'#
#' @param x An object of a class defined by the phyloseq-package. Component#
#'  data and complex classes are both acceptable.#
#' #
#' @return A named list, where each element is a component object that was contained #
#' in the argument, \code{x}. Each element is named for the object class it contains#
#' If \code{x} is already a component data object,#
#' then a list of length (1) is returned, also named.#
#'#
#' @seealso merge_phyloseq#
#' @export#
#' @examples ##
splat.phyloseq.objects <- function(x){#
	component.classes <- get.component.classes()#
	# Check if class of x is among the component classes (not H.O.)#
	if( class(x) %in% component.classes ){#
		splatx <- list(x)#
		names(splatx) <- names(component.classes)[component.classes==class(x)]#
	} else {#
		slotsx <- getSlots(class(x))#
		splatx <- lapply(slotsx, function(iclass, slotsx, x){#
			do.call(names(slotsx)[slotsx==iclass], list(x))#
		}, slotsx, x)#
	}#
	return(splatx)#
}#
#################################################################################
#' Return the non-empty slot names of a phyloseq object.#
#'#
#' Like \code{\link{getSlots}}, but returns the class name if argument #
#' is component data object.#
#' #
#' @usage getslots.phyloseq(x)#
#'#
#' @param x A \code{\link{phyloseq-class}} object. If \code{x} is a component#
#'  data class, then just returns the class of \code{x}.#
#' #
#' @return identical to getSlots. A named character vector of the slot classes#
#' of a particular S4 class, where each element is named by the slot name it#
#' represents. If \code{x} is a component data object,#
#' then a vector of length (1) is returned, named according to its slot name in#
#' the higher-order objects.#
#' #
#' @seealso merge_phyloseq#
#' @export#
#' @examples ##
getslots.phyloseq <- function(x){#
	# Check if class of x is among the component classes (not H.O.)#
	component.classes <- get.component.classes()	#
	if( class(x) %in% component.classes ){#
		slotsx        <- as.character(class(x))#
		names(slotsx) <- names(component.classes)[component.classes==class(x)]#
	} else {#
		slotsx <- getSlots(class(x))#
	}#
	return(slotsx)#
}#
#################################################################################
#' General slot accessor function for phyloseq-package.#
#'#
#' This function is used internally by many convenience accessors and in #
#' many functions/methods that need to access a particular component data type.#
#' If something is wrong, or the slot is missing, the expected behavior is that#
#' this function will return NULL. Thus, the output can be tested by #
#' \code{\link{is.null}} as verification of the presence of a particular #
#' data component. #
#'#
#' @usage access(object, slot, errorIfNULL=FALSE)#
#'#
#' @param object (Required). A phyloseq-class object.#
#'#
#' @param slot (Required). A character string indicating the slot (not data class)#
#'  of the component data type that is desired.#
#'#
#' @param errorIfNULL (Optional). Logical. Should the accessor stop with #
#'  an error if the slot is empty (\code{NULL})? Default \code{FALSE}. #
#'#
#' @return Returns the component object specified by the argument \code{slot}. #
#'  Returns NULL if slot does not exist. Returns \code{object} as-is #
#'  if it is a component class that already matches the slot name.#
#'#
#' @seealso merge_phyloseq#
#' @export#
#' @examples ##
#' ## data(ex1)#
#' ## access(ex1, "taxTab")#
#' ## access(ex1, "tre")#
#' ## access(otuTable(ex1), "otuTable")#
#' ## # Should return NULL:#
#' ## access(otuTable(ex1), "sampleMap")#
#' ## access(otuTree(ex1), "sampleMap")#
#' ## access(otuSam(ex1), "tre")#
access <- function(object, slot, errorIfNULL=FALSE){#
	component.classes <- get.component.classes()#
	# Check if class of x is among the component classes (not H.O.)#
	if( class(object) %in% component.classes ){#
		# if slot-name matches object, return object as-is.#
		if( component.classes[slot] == class(object) ){#
			out <- object#
		} else {#
			out <- NULL#
		}#
	} else if(!slot %in% slotNames(object) ){#
		out <- NULL#
	} else {#
		out <- eval(parse(text=paste("object@", slot, sep=""))) #
	}#
	# Test if you should error upon the emptiness of the slot being accessed#
	if( errorIfNULL & is.null(out) ){#
		stop(slot, " slot is empty.")#
	}#
	return(out)#
}
ps
HO
library("phylobase")
rm(list=ls())
library("phylobase")
source("/Users/pjm2/github_packages/phyloseq_bioc/R/allclasses.r")
source("~/github_packages/phyloseq_bioc/R/phyloseq.r")
phyloseq()
rm(list=ls())#
# test new classes script.#
# Need to load phylobase for phylo4 class availability#
library("phylobase")#
#
#################################################################################
# source the classes#
#################################################################################
source("/Users/pjm2/github_packages/phyloseq_bioc/R/allclasses.r")#
# Some tests of the classes#
#
#################################################################################
# Source the constructor / accessors#
#################################################################################
source("~/github_packages/phyloseq_bioc/R/phyloseq-class.R")
phyloseq()
source("/Users/pjm2/github_packages/phyloseq_bioc/R/accessor-methods.r")
new("otuTable", matrix(5,5,5), speciesAreRows=TRUE)
new("otuTable", .Data=matrix(5,5,5), speciesAreRows=TRUE)
getSlots("otuTable")
setClass("otuTable", representation(speciesAreRows="logical"), contains = "matrix")
getSlots("otuTable")
new("otuTable", matrix(5,5,5), speciesAreRows=TRUE)
OTU <- new("otuTable", matrix(5,5,5), speciesAreRows=TRUE)
OTU
phyloseq()
phyloseq(OTU)
SM  <- new("sampleMap", data.frame(x1=5, x2=rep(7, nrow=ncol(OTU))))
SM
rep(7, times=ncol(OTU))
SM  <- new("sampleMap", data.frame(x1=5, x2=rep(7, times=ncol(OTU))))
SM
phyloseq(OTU, SM)
rm(list=ls())#
# test new classes script.#
# Need to load phylobase for phylo4 class availability#
library("phylobase")#
#
#################################################################################
# source the classes#
#################################################################################
source("/Users/pjm2/github_packages/phyloseq_bioc/R/allclasses.r")#
#
# Some tests of the classes#
OTU <- new("otuTable", matrix(5,5,5), speciesAreRows=TRUE)#
SM  <- new("sampleMap", data.frame(x1=5, x2=rep(7, times=ncol(OTU))))#
#
#################################################################################
# Source the constructor / accessors#
#################################################################################
source("~/github_packages/phyloseq_bioc/R/phyloseq-class.R")
OTU
getSlots("otuTable")
rm(list=ls())#
# test new classes script.#
# Need to load phylobase for phylo4 class availability#
library("phylobase")#
#
#################################################################################
# source the classes#
#################################################################################
source("/Users/pjm2/github_packages/phyloseq_bioc/R/allclasses.r")
OTU <- new("otuTable", matrix(5,5,5), speciesAreRows=TRUE)
SM  <- new("sampleMap", data.frame(x1=5, x2=rep(7, times=ncol(OTU))))
OTU
source("~/github_packages/phyloseq_bioc/R/phyloseq-class.R")
source("/Users/pjm2/github_packages/phyloseq_bioc/R/accessor-methods.r")
phyloseq(OTU)
phyloseq(OTU, SM)
list(OTU, SM)
sapply(list(OTU, SM), splat.phyloseq.objects)
splatlist <- sapply(list(OTU, SM), splat.phyloseq.objects)
splatlist
	## Need to determine which new() type to call.#
	# First some quality-control checks:#
	if( length(splatlist) > 4){#
		stop("phyloseq()-ERROR: Too many components provided\n")#
	} else if( length(names(splatlist)) > length(unique(names(splatlist))) ){#
		stop("phyloseq()-ERROR: Only one of each component type allowed.\n",#
		"For merging multiple tables of the same class, try merge_phyloseq(...)\n")#
	} else if( length(splatlist) == 1){#
		return(arglist[[1]])#
	} else if( !"otuTable" %in% names(splatlist) ){#
		stop("phyloseq()-ERROR: Argument list must include an otuTable.\n")#
	# Instantiate the phyloseq-class object, ps.#
	} else {#
		ps <- do.call("new", c(list(Class="phyloseq"), splatlist) )#
	}
ps
splatlist
getSlots(ps)
splatlist
ps
splat.phyloseq.objects(ps)
		slotsx <- getSlots(class(x))
x <- ps
		slotsx <- getSlots(class(x))
		slotsx
getSlots(class(ps))
names(getSlots(class(ps)))
slotnames
slotnames <- names(getSlots(class(ps)))
slotnames
sapply(slotnames, access, FALSE)
sapply(slotnames, function(i, x){access(x, i, FALSE)}, ps)
allslots  <- sapply(slotnames, function(i, x){access(x, i, FALSE)}, ps)
sapply(allslots, is.null)
slotsx    <- allslots[!sapply(allslots, is.null)]
slotsx
#################################################################################
#' Convert phyloseq objects into a named list of the component type (class)#
#'#
#' @usage splat.phyloseq.objects(x)#
#'#
#' @param x An object of a class defined by the phyloseq-package. Component#
#'  data and complex classes are both acceptable.#
#' #
#' @return A named list, where each element is a component object that was contained #
#' in the argument, \code{x}. Each element is named for the object class it contains#
#' If \code{x} is already a component data object,#
#' then a list of length (1) is returned, also named.#
#'#
#' @seealso merge_phyloseq#
#' @export#
#' @examples ##
splat.phyloseq.objects <- function(x){#
	component.classes <- get.component.classes()#
	# Check if class of x is among the component classes (not H.O.)#
	if( class(x) %in% component.classes ){#
		splatx <- list(x)#
		names(splatx) <- names(component.classes)[component.classes==class(x)]#
	} else { #
		slotnames <- names(getSlots(class(x)))#
		allslots  <- sapply(slotnames, function(i, x){access(x, i, FALSE)}, x)#
		splatx    <- allslots[!sapply(allslots, is.null)]#
	}#
	return(splatx)#
}
splat.phyloseq.objects(ps)
splatlist <- sapply(list(OTU, SM), splat.phyloseq.objects)
splatlist
splat.phyloseq.objects(NULL)
(t1 <- splat.phyloseq.objects(ps))
names(t1)
#' Return the non-empty slot names of a phyloseq object.#
#'#
#' Like \code{\link{getSlots}}, but returns the class name if argument #
#' is component data object.#
#' #
#' @usage getslots.phyloseq(x)#
#'#
#' @param x A \code{\link{phyloseq-class}} object. If \code{x} is a component#
#'  data class, then just returns the class of \code{x}.#
#' #
#' @return identical to getSlots. A named character vector of the slot classes#
#' of a particular S4 class, where each element is named by the slot name it#
#' represents. If \code{x} is a component data object,#
#' then a vector of length (1) is returned, named according to its slot name in#
#' the higher-order objects.#
#' #
#' @seealso merge_phyloseq#
#' @export#
#' @examples ##
getslots.phyloseq <- function(x){#
	# Check if class of x is among the component classes (not H.O.)#
	component.classes <- get.component.classes()	#
	if( class(x) %in% component.classes ){#
		slotsx        <- as.character(class(x))#
		names(slotsx) <- names(component.classes)[component.classes==class(x)]#
	} else {#
		# Make sure to return only the names of non-empty slots of x#
		splatx <- splat.phyloseq.objects(x)#
		slotsx <- names(splatx)#
	}#
	return(slotsx)#
}#
#################################################################################
#' General slot acces
getslots.phyloseq(ps)
(t1 <- splat.phyloseq.objects(ps))
rm(list=ls())#
# test new classes script.#
# Need to load phylobase for phylo4 class availability#
library("phylobase")#
#
#################################################################################
# source the classes#
#################################################################################
source("/Users/pjm2/github_packages/phyloseq_bioc/R/allclasses.r")#
#
# Some tests of the classes#
OTU <- new("otuTable", matrix(5,5,5), speciesAreRows=TRUE)#
SM  <- new("sampleMap", data.frame(x1=5, x2=rep(7, times=ncol(OTU))))#
#
#################################################################################
# Source the constructor / accessors#
#################################################################################
source("~/github_packages/phyloseq_bioc/R/phyloseq-class.R")#
source("/Users/pjm2/github_packages/phyloseq_bioc/R/accessor-methods.r")#
#
# A test for the constructor...
# A test for the constructor...#
phyloseq(OTU)#
phyloseq(OTU, SM)#
# should only return
phyloseq(OTU)
makeNSSS <- function(current_year=as(strsplit(date(), " ", TRUE)[[1]][5], "integer"),#
	random_seed=888, #
	clan=c("Ma", "Pa", "G", "Sumi", "Tube", "Lolly", "Sandwich", "Momo", "Waiwai", "Jojo")#
	){#
#
	# Set the "seed" for randomization. Default 888 :)#
	set.seed(random_seed)#
	#
	# Define the current year, starting with 2011, so that years don't repeat#
	# but continue forward in time from 2011#
	year <- current_year - 2011 + 1#
	#
	# Run the loop the number of times required for the current year.#
	for( yr in 1:year ){#
		# Initialize the giver/recipient table for each year.#
		NSSS <- data.frame(giver=clan, recipient1=NA, recipient2); rownames(NSSS) <- clan#
		#
		# Initialize the set of possible recipients for each year.#
		receives <- clan#
		#
		# The main table-filling loop and if/test for random NSSS selection.#
		for( j in clan ){#
			# Check that giver is not the only remaining recipient.#
			if( length(receives)==1 & any(j==receives) ){#
				# Randomly switch recipients with one other giver.#
				switch_recipients <- sample(clan[-which(clan==j)], 1)#
				NSSS[j, "recipient"] <- NSSS[switch_recipients, "recipient"]#
				NSSS[switch_recipients, "recipient"] <- j#
				#
			# Else, everything fine, finish table.	#
			} else {#
				# make sure giver doesn't give to himself/herself#
				receivej <- receives[ receives != j ]#
				#
				# Randomly determine recipient from receivej#
				receivej <- sample(receivej, 1)#
				#
				# Once a recipient is chosen, pop it from the available recipients#
				receives <- receives[-which(receives==receivej)]#
				#
				# Add to new NSSS recipient to NSSS-table#
				NSSS[j, "recipient"] <- receivej		#
			}#
		}#
	}#
	return(NSSS)#
}#
#################################################################################
# Run makeNSSS(), and print the table to screen#
#################################################################################
makeNSSS(2011)
#################################################################################
# Remove everything from the main environment workspace to avoid conflicts bugs.#
rm(list=ls())#
#
makeNSSS <- function(current_year=as(strsplit(date(), " ", TRUE)[[1]][5], "integer"),#
	random_seed=888, #
	clan=c("Ma", "Pa", "G", "Sumi", "Tube", "Lolly", "Sandwich", "Momo", "Waiwai", "Jojo")#
	){#
#
	# Set the "seed" for randomization. Default 888 :)#
	set.seed(random_seed)#
	#
	# Define the current year, starting with 2011, so that years don't repeat#
	# but continue forward in time from 2011#
	year <- current_year - 2011 + 1#
	#
	# Run the loop the number of times required for the current year.#
	for( yr in 1:year ){#
		# Initialize the giver/recipient table for each year.#
		NSSS <- data.frame(giver=clan, recipient1=NA); rownames(NSSS) <- clan#
		#
		# Initialize the set of possible recipients for each year.#
		receives <- clan#
		#
		# The main table-filling loop and if/test for random NSSS selection.#
		for( j in clan ){#
			# Check that giver is not the only remaining recipient.#
			if( length(receives)==1 & any(j==receives) ){#
				# Randomly switch recipients with one other giver.#
				switch_recipients <- sample(clan[-which(clan==j)], 1)#
				NSSS[j, "recipient"] <- NSSS[switch_recipients, "recipient"]#
				NSSS[switch_recipients, "recipient"] <- j#
				#
			# Else, everything fine, finish table.	#
			} else {#
				# make sure giver doesn't give to himself/herself#
				receivej <- receives[ receives != j ]#
				#
				# Randomly determine recipient from receivej#
				receivej <- sample(receivej, 1)#
				#
				# Once a recipient is chosen, pop it from the available recipients#
				receives <- receives[-which(receives==receivej)]#
				#
				# Add to new NSSS recipient to NSSS-table#
				NSSS[j, "recipient"] <- receivej		#
			}#
		}#
	}#
	return(NSSS)#
}#
#################################################################################
# Run makeNSSS(), and print the table to screen#
#################################################################################
makeNSSS(2011)
makeNSSS <- function(current_year=as(strsplit(date(), " ", TRUE)[[1]][5], "integer"),#
	random_seed=888, #
	clan=c("Ma", "Pa", "G", "Sumi", "Tube", "Lolly", "Sandwich", "Momo", "Waiwai", "Jojo")#
	){#
#
	# Set the "seed" for randomization. Default 888 :)#
	set.seed(random_seed)#
	#
	# Define the current year, starting with 2011, so that years don't repeat#
	# but continue forward in time from 2011#
	year <- current_year - 2011 + 1#
	#
	# Run the loop the number of times required for the current year.#
	for( yr in 1:year ){#
		# Initialize the giver/recipient table for each year.#
		NSSS <- data.frame(giver=clan, recipient=NA); rownames(NSSS) <- clan#
		#
		# Initialize the set of possible recipients for each year.#
		receives <- clan#
		#
		# The main table-filling loop and if/test for random NSSS selection.#
		for( j in clan ){#
			# Check that giver is not the only remaining recipient.#
			if( length(receives)==1 & any(j==receives) ){#
				# Randomly switch recipients with one other giver.#
				switch_recipients <- sample(clan[-which(clan==j)], 1)#
				NSSS[j, "recipient"] <- NSSS[switch_recipients, "recipient"]#
				NSSS[switch_recipients, "recipient"] <- j#
				#
			# Else, everything fine, finish table.	#
			} else {#
				# make sure giver doesn't give to himself/herself#
				receivej <- receives[ receives != j ]#
				#
				# Randomly determine recipient from receivej#
				receivej <- sample(receivej, 1)#
				#
				# Once a recipient is chosen, pop it from the available recipients#
				receives <- receives[-which(receives==receivej)]#
				#
				# Add to new NSSS recipient to NSSS-table#
				NSSS[j, "recipient"] <- receivej		#
			}#
		}#
	}#
	return(NSSS)#
}#
#################################################################################
# Run makeNSSS(), and print the table to screen#
#################################################################################
makeNSSS(2011)
a2011 <- makeNSSS(2011)
cat(a2011)
a2011[, "recipient"]
a2011[, "recipient", drop=FALSE]
makeNSSS(2012)
makeNSSS(2012)[, "recipient", drop=FALSE]
library("vegan")
?plot.cca
?cca.object
library("ape")
?consensus
list(NULL, NULL)
do.call("sum", list(3,3,NULL,NULL,5))
do.call("print", list(3,3,NULL,NULL,5))
?"phylo-class"
?"phylo"
?"phylo4-class"
library('phylobase')
?"phylo4-class"
##########
# Now load and re-save as an object from new package#
library("phyloseq")#
data(ex1)#
# # # # # newex1name <- "/Users/joeyMP/github/phyloseq_bioc/data/ex1.RData"#
newex1name <- "/Users/pjm2/github_packages/phyloseq_bioc/data/ex1.RData"#
# # # load(newex1name)#
#
ex1 <- phyloseq(otuTable(ex1), sampleMap(ex1), taxTab(ex1), tre(ex1))#
#
save(list="ex1", file=newex1name)
ex1
phyloseq(otuTable(ex1), sampleMap(ex1))
ex1
sampleMap(ex1) <- sampleMap(ex1)
tre(ex1) <- tre(ex1)
otuTable(ex1) <- otuTable(ex1)
taxTab(ex1) <- taxTab(ex1)
#################################################################################
data(ex1)#
ex2 <- ex1#
otuTable(ex2) <- otuTable(ex1)#
sampleMap(ex2) <- sampleMap(ex1)#
taxTab(ex2) <- taxTab(ex1)#
tre(ex2) <- tre(ex1)#
identical(ex1, ex2)
ex1
ex2
?identical
Comparison(ex1, ex2)
Compare(ex1, ex2)
Ops(ex1, ex2)
#################################################################################
data(ex1)#
ex2 <- ex1#
identical(ex1, ex2)
identical(otuTable(ex1), otuTable(ex2))
otuTable(ex2) <- otuTable(ex1)
identical(otuTable(ex1), otuTable(ex2))
identical(ex1, ex2)
ex2 <- ex1
identical(ex1, ex2)
identical(otuTable(ex1), otuTable(ex2))
getslots.phyloseq(ex1)
getslots.phyloseq(ex1)[1]
i<-getslots.phyloseq(ex1)[1]
	do.call(i, ex1, FALSE)
	do.call(i, list(ex1, FALSE))
sapply(getslots.phyloseq(ex1), function(i, x1, x2){ # i<-getslots.phyloseq(ex1)[1]#
	identical(do.call(i, list(ex1, FALSE)), do.call(i, list(ex2, FALSE)))#
}, ex1, ex2)
sapply(getslots.phyloseq(ex1), function(i, x1, x2){ # i<-getslots.phyloseq(ex1)[1]#
	identical(do.call(i, list(x1, FALSE)), do.call(i, list(x2, FALSE)))#
}, ex1, ex2)
test
test <- sapply(getslots.phyloseq(ex1), function(i, x1, x2){ # i<-getslots.phyloseq(ex1)[1]#
	identical( do.call(i, list(x1, FALSE)), do.call(i, list(x2, FALSE)) )#
}, ex1, ex2)
test
splat.phyloseq.objects(ex1)
sapply(splat.phyloseq.objects(ex1), class)
getslots.phyloseq(ex1)
sapply(getslots.phyloseq(ex1), function(i, x1){ # i<-getslots.phyloseq(ex1)[1]#
	do.call(i, list(x1, FALSE))#
}, ex1)
t1 <- sapply(splat.phyloseq.objects(ex1), class)#
sapply(getslots.phyloseq(ex1), function(i, x1){ # i<-getslots.phyloseq(ex1)[1]#
	class(do.call(i, list(x1, FALSE)))#
}, ex1)
identical(t1, t2)
t2 <- sapply(getslots.phyloseq(ex1), function(i, x1){ class(do.call(i, list(x1, FALSE))) }, ex1)
identical(t1, t2)
test <- sapply(getslots.phyloseq(ex1), function(i, x1, x2){ # i<-getslots.phyloseq(ex1)[1]#
	identical( do.call(i, list(x1, FALSE)), do.call(i, list(x2, FALSE)) )#
}, ex1, ex2)
test
all(test)
test <- sapply(getslots.phyloseq(ex1), function(i, x1, x2){ # i<-getslots.phyloseq(ex1)[1]#
	identical( do.call(i, list(x1, FALSE)), do.call(i, list(x2, FALSE)) )#
}, ex1, ex2)
test
#################################################################################
data(ex1)#
t1 <- sapply(splat.phyloseq.objects(ex1), class)#
t2 <- sapply(getslots.phyloseq(ex1), function(i, x1){ class(do.call(i, list(x1, FALSE))) }, ex1)#
identical(t1, t2)
#################################################################################
data(ex1)#
ex2 <- ex1#
otuTable(ex2)  <- otuTable(ex1)#
sampleMap(ex2) <- sampleMap(ex1)#
taxTab(ex2)    <- taxTab(ex1)#
tre(ex2)       <- tre(ex1)#
test <- sapply(getslots.phyloseq(ex1), function(i, x1, x2){ # i<-getslots.phyloseq(ex1)[1]#
	identical( do.call(i, list(x1, FALSE)), do.call(i, list(x2, FALSE)) )#
}, ex1, ex2)#
all(test)
matx <- as(x1, "matrix")
x1 <- otuTable(ex1)
matx <- as(x1, "matrix")
data(ex1)
ex1 <- otuTable(ex1)
matx <- as(ex1, "matrix")
#################################################################################
data(ex1)#
ex1  <- otuTable(ex1)#
matx <- as(ex1, "matrix")#
ex2  <- otuTable(matx, speciesAreRows(ex1))#
identical(ex1, ex2)
ex2
ex1
?identical
all.equal(ex1, ex2)
attr.all.equal(ex1, ex2)
attributes(ex1)
attributes(ex2)
identical(attributes(ex1), attributes(ex2))
all.equal(attributes(ex1), attributes(ex2))
attributes(ex1)[[3]]
attributes(ex2)[[3]]
??case
?upper
?uppercase
substr("QIIME", 1, 1)
"You need to select among available importer types:\n",#
		"\"mothur\", \"pyrotagger\", \"QIIME\", \"RDP\" \n See ?import for details"
cat("You need to select among available importer types:\n",#
		"\"mothur\", \"pyrotagger\", \"QIIME\", \"RDP\" \n See ?import for details")
library("phyloseq")
data(ex1)
ex100 <- prune_species(species.names(ex1)[1:100], ex1)#
ex200 <- prune_species(species.names(ex1)[1:200], ex1)#
#
# Should work#
merge_phyloseq(otuTable(ex100), ex200)#
t1 <- merge_phyloseq(otuTable(ex100), otuTable(ex200))#
identical(getSamples(t1, "otuID_3"), 2*getSamples(ex100, "otuID_3"))
merge_phyloseq(ex100, ex200)
tre(ex200)
t2 <- merge_species(otuTable(ex100), otuTable(ex200), tre(ex200))
t2 <- merge_phyloseq(otuTable(ex100), otuTable(ex200), tre(ex200))
t2
identical(getSamples(t2, "otuID_3"), 2*getSamples(ex100, "otuID_3"))
merge_phyloseq(sampleMap(ex100), sampleMap(ex200))
(class(t3) == "sampleMap")
t3 <- merge_phyloseq(sampleMap(ex100), sampleMap(ex200))
(class(t3) == "sampleMap")
t4 <- merge_phyloseq(taxTab(ex100), taxTab(ex200))
(class(t4) == "taxonomyTable")
t5 <- merge_phyloseq(tre(ex100), tre(ex200))
t5 <- merge_phyloseq( tre(ex200) )
(class(t5) == "phylo4")
t4
(species.names(t4))
identical(species.names(t4), species.names(ex200))
setequal(species.names(t4), species.names(ex200))
?plot_ordination_phyloseq
?"ape-package"
?tipLabels
?phylobase::tipLabels
?edgelabels
?points
?text
library("ape")
setClassUnion("phyloOrNULL", c("phylo", "NULL")) # suppress warnings?
setwd("~/github_packages/phyloseq_bioc/R")#
source('allClasses.R')#
source('allPackage.R')#
source('allData.R')#
source('as-methods.r')#
source('replacement-methods.r')#
source('show-methods.r')#
source('plot-methods.r')#
source('unifrac.r')#
source('extract-methods.r')#
source('almostAllAccessors.R')#
source('otuTable-class.R')#
source('phyloseq-class.R')#
source('sampleMap-class.R')#
source('taxonomyTable-class.R')#
source('IO-methods.R')#
source('merge-methods.R')#
source('multtest-wrapper.R')#
source('ordination-methods.R')#
source('transform_filter-methods.R')
#################################################################################
#' The S4 class for storing taxa-abundance information.#
#'#
#' Because orientation of these tables can vary by method, the orientation is#
#' defined explicitly in the \code{speciesAreRows} slot (a logical).#
#' The \code{otuTable} class inherits the \code{\link{matrix}} class to store#
#' abundance values.#
#' Various standard subset and assignment nomenclature has been extended to apply#
#' to the \code{otuTable} class, including square-bracket, \code{\link{t}}, etc.#
#'#
#' \describe{#
#'    \item{speciesAreRows}{#
#'		A single logical specifying the orientation of the abundance table.#
#'    }#
#'#
#'    \item{.Data}{This slot is inherited from the \code{\link{matrix}} class.}#
#'  }#
#' @name otuTable-class#
#' @rdname otuTable-class#
#' @exportClass otuTable#
setClass("otuTable", representation(speciesAreRows="logical"), contains = "matrix")#
#################################################################################
#' The S4 for storing sample variables.#
#'#
#' Row indices represent samples, while column indices represent experimental#
#' categories, variables (and so forth) that describe the samples.#
#'#
#' \describe{#
#'#
#'    \item{.Data}{data-frame data, inherited from the data.frame class.}#
#' #
#'    \item{row.names}{#
#'	     Also inherited from the data.frame class;#
#'       it should contain the sample names.#
#'    }#
#' #
#'    \item{names}{Inherited from the data.frame class.}#
#' #
#'  }#
#' #
#' @name sampleMap-class#
#' @rdname sampleMap-class#
#' @exportClass sampleMap#
setClass("sampleMap", contains="data.frame")#
#################################################################################
#' An S4 class that holds taxonomic classification data as a character#
#' matrix.#
#'#
#' Row indices represent taxa, columns represent taxonomic classifiers.#
#' #
#' \describe{#
#'    \item{.Data}{This slot is inherited from the \code{\link{matrix}} class.}#
#' }#
#'#
#' @name taxonomyTable-class#
#' @rdname taxonomyTable-class#
#' @exportClass taxonomyTable#
setClass("taxonomyTable", contains = "matrix")#
#################################################################################
# Use setClassUnion to define the unholy NULL-data union as a virtual class.#
# This is a way of dealing with the expected scenarios in which one or more of#
# the component data classes is not available, in which case NULL will be used#
# instead.#
#################################################################################
#' @keywords internal#
setClassUnion("otuTableOrNULL", c("otuTable", "NULL"))#
#' @keywords internal#
setClassUnion("sampleMapOrNULL", c("sampleMap", "NULL"))#
#' @keywords internal#
setClassUnion("taxonomyTableOrNULL", c("taxonomyTable", "NULL"))#
#' @keywords internal#
#' @import ape#
setOldClass("phylo")#
setClassUnion("phyloOrNULL", c("phylo", "NULL"))#
#################################################################################
# The actual phyloseq master class with all 4 slots. This is akin to #
# the otuSamTaxTree class of previous versions, but #
# with the possibility of empty (NULL) slots and an explicit prototype #
# for slots to be NULL if they are not provided at instantiation.#
#################################################################################
#' The main experiment-level class for phyloseq data#
#'#
#' Contains all component classes: #
#' \code{\link{otuTable-class}},#
#' \code{\link{sampleMap-class}},#
#' \code{\link{taxonomyTable-class}} (\code{"taxTab"} slot), and#
#' \code{\link[ape]{phylo}}-class (\code{"tre"} slot). There are several advantages#
#' to storing your phylogenetic sequencing experiment as an instance of the#
#' phyloseq class, not the least of which is that it is easy to return to the#
#' data later and feel confident that the different data types ``belong'' to#
#' one another. Furthermore, the \code{\link{phyloseq}} constructor ensures that#
#' the different data components have compatible indices (e.g. species and samples),#
#' and performs the necessary trimming automatically when you create your#
#' ``experiment-level'' object. Downstream analyses are aware of which data#
#' classes they require -- and where to find them -- often making your #
#' \code{phyloseq-class} object the only data argument to analysis and plotting#
#' functions (although there are many options and parameter arguments waiting#
#' for you). #
#'#
#' In the case of missing component data, the slots are set to \code{NULL}. As#
#' soon as a \code{phyloseq-class} object is to be updated with new component#
#' data (previously missing/\code{NULL} or not), the indices of all components#
#' are re-checked for compatibility and trimmed if necessary. This is to ensure#
#' by design that components describe the same taxa/samples, and also that these#
#' trimming/validity checks do not need to be repeated in downstream analyses.#
#' #
#' slots:#
#' \describe{#
#'    \item{otuTable}{a single object of class otuTable.}#
#'    \item{sampleMap}{ a single object of class sampleMap.}#
#'    \item{taxTab}{ a single object of class taxonomyTable.}#
#'    \item{tre}{ a single object of class phylo, from the package ape}#
#' }#
#' @seealso The constructor, \code{\link{phyloseq}}, #
#'  the merger \code{\link{merge_phyloseq}}, and also the component #
#'  constructor/accessors \code{\link{otuTable}}, \code{\link{sampleMap}},#
#'  \code{\link{taxTab}}, and \code{\link{tre}}.#
#' #
#' @name phyloseq-class#
#' @rdname phyloseq-class#
#' @exportClass phyloseq#
setClass(Class="phyloseq", #
	representation=representation(#
		otuTable="otuTableOrNULL",#
		taxTab="taxonomyTableOrNULL",#
		sampleMap="sampleMapOrNULL",#
		tre="phyloOrNULL"),#
	prototype=prototype(otuTable=NULL, taxTab=NULL, sampleMap=NULL, tre=NULL)#
)
"phylo"
